import json
from channels.generic.websocket import AsyncWebsocketConsumer
import redis
import asyncio
import uuid
from app.worker import WorkerPool, PredictWorker

import logging

class PredictConsumer(AsyncWebsocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.worker_pool = WorkerPool()
        self.worker_pool.startWorker()
    async def connect(self):
        
        try:
            self.redis_client = redis.StrictRedis(
                host='localhost',
                port=6379,
                db=0,
                decode_responses=True
            )
            
            await self.accept()
            print("WebSocket connection established")
        except Exception as e:
            print(f"WebSocket connection error: {e}")
            await self.close()

    async def receive(self, text_data):
        predictWorker = PredictWorker(session_id, user_message)
        data = json.loads(text_data)
        user_message = data['message']
        session_id = str(uuid.uuid4())
        print(user_message)
        print(f"New request for session {session_id}")
        
        if(self.redis_client.get(session_id) != None and self.redis_client.get(session_id) != "" ):
            self.worker_pool.removeWorker(predictWorker)
            token = self.redis_client.get(session_id)
            await self.send(text_data=json.dumps({
                        'status': 'streaming',
                        'response': token
                        }))
        else:
            if(predictWorker not in self.worker_pool.queueWorker):
                self.worker_pool.addWorker(predictWorker)
            
    async def disconnect(self, close_code):
        print("WebSocket connection closed")
